<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rag Doll Arena</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    #gameCanvas {
      display: block;
      background: #000;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 8px 12px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
    }

    .ui-left, .ui-right {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 24px;
      letter-spacing: 2px;
      text-align: center;
      text-shadow: 0 0 12px #fff;
      pointer-events: none;
      opacity: 0.1;
    }

    .hint {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #aaa;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui-overlay">
    <div class="ui-left">
      <div>Score: <span id="scoreText">0</span></div>
      <div>Rank: <span id="rankText">Fledgling</span></div>
    </div>
    <div class="ui-right">
      <div>Wave: <span id="waveText">1</span></div>
      <div>HP: <span id="hpText">100</span></div>
    </div>
  </div>

  <div class="title">RAG DOLL ARENA</div>
  <div class="hint">Swipe to dash. Stay near enemies to auto‑attack.</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreText = document.getElementById('scoreText');
    const rankText = document.getElementById('rankText');
    const waveText = document.getElementById('waveText');
    const hpText = document.getElementById('hpText');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    // ---------- RAGDOLL HELPERS ----------

    function createRagdoll(x, y, scale = 1, color = '#ffffff') {
      const s = scale;
      return {
        x, y,
        color,
        alive: true,
        angle: 0,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 1 + Math.random(),
        // segments: head, body, arms, legs (relative)
        parts: {
          head: { ox: 0, oy: -18 * s, r: 6 * s },
          bodyTop: { ox: 0, oy: -12 * s },
          bodyBottom: { ox: 0, oy: 10 * s },
          leftHand: { ox: -10 * s, oy: 0 },
          rightHand: { ox: 10 * s, oy: 0 },
          leftFoot: { ox: -7 * s, oy: 22 * s },
          rightFoot: { ox: 7 * s, oy: 22 * s }
        },
        // when dead, we turn into loose pieces
        deadPieces: [],
        vx: 0,
        vy: 0
      };
    }

    function killRagdoll(r, power = 2) {
      if (!r.alive) return;
      r.alive = false;
      r.deadPieces = [];

      const base = { x: r.x, y: r.y };
      const push = () => (Math.random() - 0.5) * power;

      // create loose pieces from parts
      const addPiece = (name, size = 4) => {
        const p = r.parts[name];
        r.deadPieces.push({
          x: base.x + p.ox,
          y: base.y + p.oy,
          vx: push(),
          vy: -Math.random() * power,
          size,
          life: 4000
        });
      };

      addPiece('head', 6);
      addPiece('bodyTop', 5);
      addPiece('bodyBottom', 5);
      addPiece('leftHand', 3);
      addPiece('rightHand', 3);
      addPiece('leftFoot', 3);
      addPiece('rightFoot', 3);
    }

    function updateDeadRagdoll(r, dt) {
      const g = 0.0025 * dt;
      r.deadPieces.forEach(p => {
        p.vy += g;
        p.x += p.vx * (dt / 16);
        p.y += p.vy * (dt / 16);
        p.life -= dt;
      });
      r.deadPieces = r.deadPieces.filter(p => p.life > 0);
    }

    function drawRagdoll(r, isPlayer = false) {
      ctx.save();
      ctx.translate(r.x, r.y);

      if (r.alive) {
        // subtle wobble
        r.wobble += r.wobbleSpeed * 0.03;
        const wob = Math.sin(r.wobble) * 3;

        ctx.strokeStyle = r.color;
        ctx.lineWidth = isPlayer ? 3 : 2;
        ctx.lineCap = 'round';

        // glow
        const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 40);
        glow.addColorStop(0, r.color);
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, 40, 0, Math.PI * 2);
        ctx.fill();

        const p = r.parts;

        // body
        ctx.beginPath();
        ctx.moveTo(p.bodyTop.ox, p.bodyTop.oy + wob * 0.1);
        ctx.lineTo(p.bodyBottom.ox, p.bodyBottom.oy + wob * 0.2);
        ctx.stroke();

        // arms
        ctx.beginPath();
        ctx.moveTo(p.bodyTop.ox, p.bodyTop.oy + wob * 0.1);
        ctx.lineTo(p.leftHand.ox, p.leftHand.oy + wob);
        ctx.moveTo(p.bodyTop.ox, p.bodyTop.oy + wob * 0.1);
        ctx.lineTo(p.rightHand.ox, p.rightHand.oy - wob);
        ctx.stroke();

        // legs
        ctx.beginPath();
        ctx.moveTo(p.bodyBottom.ox, p.bodyBottom.oy + wob * 0.2);
        ctx.lineTo(p.leftFoot.ox, p.leftFoot.oy + wob);
        ctx.moveTo(p.bodyBottom.ox, p.bodyBottom.oy + wob * 0.2);
        ctx.lineTo(p.rightFoot.ox, p.rightFoot.oy - wob);
        ctx.stroke();

        // head
        ctx.beginPath();
        ctx.arc(p.head.ox, p.head.oy + wob * 0.1, p.head.r, 0, Math.PI * 2);
        ctx.stroke();
      } else {
        // dead pieces
        ctx.fillStyle = r.color;
        r.deadPieces.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x - r.x, p.y - r.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      ctx.restore();
    }

    // ---------- GAME STATE ----------

    const player = {
      ragdoll: createRagdoll(width / 2, height / 2, 1.1, '#ffffff'),
      baseSpeed: 2.2,
      dashSpeed: 9,
      dashTime: 0,
      dashDuration: 120,
      dashDir: { x: 0, y: 0 },
      hp: 100,
      maxHp: 100,
      attackRange: 130,
      attackCooldown: 450,
      lastAttack: 0,
      rank: 'Fledgling',
      glowColor: '#ffffff'
    };

    let enemies = [];
    let particles = [];
    let projectiles = [];
    let lastTime = performance.now();
    let score = 0;
    let wave = 1;
    let spawnTimer = 0;
    let spawnInterval = 1200;
    let gameOver = false;

    // Touch / swipe
    let touchStart = null;
    const minSwipeDist = 40;

    canvas.addEventListener('touchstart', (e) => {
      const t = e.touches[0];
      touchStart = { x: t.clientX, y: t.clientY, time: performance.now() };
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (!touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      const dist = Math.hypot(dx, dy);
      const dt = performance.now() - touchStart.time;

      if (dist > minSwipeDist && dt < 400) {
        const nx = dx / dist;
        const ny = dy / dist;
        dash(nx, ny);
      }

      touchStart = null;
    });

    function dash(nx, ny) {
      player.dashDir.x = nx;
      player.dashDir.y = ny;
      player.dashTime = player.dashDuration;
    }

    // Rank + glow color based on score
    function updateRank() {
      let newRank;
      let color;

      if (score < 20) {
        newRank = 'Fledgling';
        color = '#ffffff';
      } else if (score < 60) {
        newRank = 'Wraith';
        color = '#4da6ff';
      } else if (score < 120) {
        newRank = 'Nightblade';
        color = '#b266ff';
      } else if (score < 200) {
        newRank = 'Void Reaper';
        color = '#ff4444';
      } else {
        newRank = 'Apex Shade';
        color = '#ffd700';
      }

      player.rank = newRank;
      player.glowColor = color;
      player.ragdoll.color = color;
      rankText.textContent = newRank;
    }

    function spawnEnemy() {
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      const margin = 40;

      if (edge === 0) {
        x = Math.random() * width;
        y = -margin;
      } else if (edge === 1) {
        x = width + margin;
        y = Math.random() * height;
      } else if (edge === 2) {
        x = Math.random() * width;
        y = height + margin;
      } else {
        x = -margin;
        y = Math.random() * height;
      }

      const speed = 0.7 + Math.random() * (0.4 + wave * 0.1);
      const rag = createRagdoll(x, y, 1, '#8888ff');
      const enemy = {
        ragdoll: rag,
        speed,
        hp: 3 + wave,
        maxHp: 3 + wave,
        damage: 8 + wave * 1.2,
        attackRange: 26,
        attackCooldown: 900,
        lastAttack: 0
      };
      enemies.push(enemy);
    }

    function spawnFogParticle() {
      const p = {
        x: Math.random() * width,
        y: Math.random() * height,
        radius: 20 + Math.random() * 60,
        alpha: 0.02 + Math.random() * 0.05,
        driftX: (Math.random() - 0.5) * 0.1,
        driftY: (Math.random() - 0.5) * 0.1
      };
      particles.push(p);
    }

    for (let i = 0; i < 40; i++) spawnFogParticle();

    function spawnProjectile(target) {
      const px = player.ragdoll.x;
      const py = player.ragdoll.y;
      const angle = Math.atan2(target.ragdoll.y - py, target.ragdoll.x - px);
      const speed = 6;
      const proj = {
        x: px,
        y: py,
        radius: 6,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        damage: 4 + wave * 0.8,
        life: 800
      };
      projectiles.push(proj);
    }

    function update(dt) {
      if (gameOver) return;

      // Fog
      particles.forEach(p => {
        p.x += p.driftX * dt;
        p.y += p.driftY * dt;
        if (p.x < -100) p.x = width + 100;
        if (p.x > width + 100) p.x = -100;
        if (p.y < -100) p.y = height + 100;
        if (p.y > height + 100) p.y = -100;
      });

      // Player dash
      if (player.dashTime > 0) {
        const dashStep = player.dashSpeed * (dt / 16);
        player.ragdoll.x += player.dashDir.x * dashStep;
        player.ragdoll.y += player.dashDir.y * dashStep;
        player.dashTime -= dt;
      }

      // Clamp player
      player.ragdoll.x = Math.max(10, Math.min(width - 10, player.ragdoll.x));
      player.ragdoll.y = Math.max(10, Math.min(height - 10, player.ragdoll.y));

      // Enemy spawn / waves
      spawnTimer += dt;
      if (spawnTimer > spawnInterval) {
        spawnTimer = 0;
        for (let i = 0; i < 1 + Math.floor(wave * 0.6); i++) {
          spawnEnemy();
        }
        wave++;
        waveText.textContent = wave;
        spawnInterval = Math.max(500, 1200 - wave * 20);
      }

      const now = performance.now();

      // Enemies
      enemies.forEach(enemy => {
        const r = enemy.ragdoll;
        if (r.alive) {
          const dx = player.ragdoll.x - r.x;
          const dy = player.ragdoll.y - r.y;
          const dist = Math.hypot(dx, dy);

          if (dist > 1) {
            const nx = dx / dist;
            const ny = dy / dist;
            r.x += nx * enemy.speed * (dt / 16);
            r.y += ny * enemy.speed * (dt / 16);
          }

          // Attack player
          if (dist < enemy.attackRange + 10) {
            if (now - enemy.lastAttack > enemy.attackCooldown) {
              enemy.lastAttack = now;
              player.hp -= enemy.damage;
              hpText.textContent = Math.max(0, Math.floor(player.hp));

              for (let i = 0; i < 6; i++) {
                particles.push({
                  x: player.ragdoll.x,
                  y: player.ragdoll.y,
                  radius: 6 + Math.random() * 10,
                  alpha: 0.15,
                  driftX: (Math.random() - 0.5) * 0.8,
                  driftY: (Math.random() - 0.5) * 0.8
                });
              }

              if (player.hp <= 0 && player.ragdoll.alive) {
                killRagdoll(player.ragdoll, 3);
                gameOver = true;
              }
            }
          }
        } else {
          updateDeadRagdoll(r, dt);
        }
      });

      // Auto‑attack
      if (now - player.lastAttack > player.attackCooldown && player.ragdoll.alive) {
        let nearest = null;
        let nearestDist = Infinity;
        enemies.forEach(enemy => {
          if (!enemy.ragdoll.alive) return;
          const dx = enemy.ragdoll.x - player.ragdoll.x;
          const dy = enemy.ragdoll.y - player.ragdoll.y;
          const dist = Math.hypot(dx, dy);
          if (dist < player.attackRange && dist < nearestDist) {
            nearestDist = dist;
            nearest = enemy;
          }
        });

        if (nearest) {
          player.lastAttack = now;
          spawnProjectile(nearest);
        }
      }

      // Projectiles
      projectiles.forEach(proj => {
        proj.x += proj.vx * (dt / 16);
        proj.y += proj.vy * (dt / 16);
        proj.life -= dt;
      });

      // Projectile‑enemy collisions
      projectiles.forEach((proj) => {
        enemies.forEach((enemy) => {
          if (!enemy.ragdoll.alive) return;
          const dx = enemy.ragdoll.x - proj.x;
          const dy = enemy.ragdoll.y - proj.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 20 + proj.radius) {
            enemy.hp -= proj.damage;
            proj.life = 0;

            for (let i = 0; i < 5; i++) {
              particles.push({
                x: enemy.ragdoll.x,
                y: enemy.ragdoll.y,
                radius: 4 + Math.random() * 8,
                alpha: 0.2,
                driftX: (Math.random() - 0.5) * 1.2,
                driftY: (Math.random() - 0.5) * 1.2
              });
            }

            if (enemy.hp <= 0 && enemy.ragdoll.alive) {
              killRagdoll(enemy.ragdoll, 2.5);
              score += 5;
              scoreText.textContent = score;
              updateRank();
            }
          }
        });
      });

      // Cleanup
      projectiles = projectiles.filter(p =>
        p.life > 0 &&
        p.x > -50 && p.x < width + 50 &&
        p.y > -50 && p.y < height + 50
      );

      enemies = enemies.filter(e => {
        if (!e.ragdoll.alive && e.ragdoll.deadPieces.length === 0) {
          return false;
        }
        return true;
      });

      // Update dead player ragdoll if needed
      if (!player.ragdoll.alive) {
        updateDeadRagdoll(player.ragdoll, dt);
      }
    }

    function draw() {
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);

      // Fog
      particles.forEach(p => {
        const gradient = ctx.createRadialGradient(
          p.x, p.y, 0,
          p.x, p.y, p.radius
        );
        gradient.addColorStop(0, `rgba(255,255,255,${p.alpha})`);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      });

      // Projectiles
      projectiles.forEach(proj => {
        const gradient = ctx.createRadialGradient(
          proj.x, proj.y, 0,
          proj.x, proj.y, proj.radius * 2
        );
        gradient.addColorStop(0, player.glowColor);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.radius * 2, 0, Math.PI * 2);
        ctx.fill();
      });

      // Enemies
      enemies.forEach(enemy => {
        drawRagdoll(enemy.ragdoll, false);
      });

      // Player
      drawRagdoll(player.ragdoll, true);

      if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.font = '24px system-ui';
        ctx.fillText('You fell into the void.', width / 2, height / 2 - 10);
        ctx.font = '16px system-ui';
        ctx.fillText('Refresh to restart Rag Doll Arena.', width / 2, height / 2 + 20);
      }
    }

    function loop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    updateRank();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
