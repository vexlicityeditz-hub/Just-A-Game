<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rag Doll Arena</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: #fff;
    }

    #gameCanvas {
      display: block;
      background: #000;
    }

    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 8px 12px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      font-size: 14px;
      text-shadow: 0 0 4px #000;
    }

    .ui-left, .ui-right {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .title {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 24px;
      letter-spacing: 2px;
      text-align: center;
      text-shadow: 0 0 12px #fff;
      pointer-events: none;
      opacity: 0.1;
    }

    .hint {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #aaa;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui-overlay">
    <div class="ui-left">
      <div>Score: <span id="scoreText">0</span></div>
      <div>Rank: <span id="rankText">Fledgling</span></div>
    </div>
    <div class="ui-right">
      <div>Wave: <span id="waveText">1</span></div>
      <div>HP: <span id="hpText">100</span></div>
    </div>
  </div>

  <div class="title">RAG DOLL ARENA</div>
  <div class="hint">Swipe to dash. Stay near enemies to auto‑attack.</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreText = document.getElementById('scoreText');
    const rankText = document.getElementById('rankText');
    const waveText = document.getElementById('waveText');
    const hpText = document.getElementById('hpText');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    // Game state
    const player = {
      x: width / 2,
      y: height / 2,
      radius: 18,
      baseSpeed: 2.2,
      dashSpeed: 9,
      dashTime: 0,
      dashDuration: 120, // ms
      dashDir: { x: 0, y: 0 },
      hp: 100,
      maxHp: 100,
      attackRange: 120,
      attackCooldown: 450, // ms
      lastAttack: 0,
      rank: 'Fledgling',
      glowColor: '#ffffff'
    };

    let enemies = [];
    let particles = [];
    let projectiles = [];
    let lastTime = performance.now();
    let score = 0;
    let wave = 1;
    let spawnTimer = 0;
    let spawnInterval = 1200; // ms
    let gameOver = false;

    // Touch / swipe
    let touchStart = null;
    const minSwipeDist = 40;

    canvas.addEventListener('touchstart', (e) => {
      const t = e.touches[0];
      touchStart = { x: t.clientX, y: t.clientY, time: performance.now() };
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (!touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      const dist = Math.hypot(dx, dy);
      const dt = performance.now() - touchStart.time;

      if (dist > minSwipeDist && dt < 400) {
        const nx = dx / dist;
        const ny = dy / dist;
        dash(nx, ny);
      }

      touchStart = null;
    });

    function dash(nx, ny) {
      player.dashDir.x = nx;
      player.dashDir.y = ny;
      player.dashTime = player.dashDuration;
    }

    // Rank + glow color based on score
    function updateRank() {
      let newRank;
      let color;

      if (score < 20) {
        newRank = 'Fledgling';
        color = '#ffffff'; // white
      } else if (score < 60) {
        newRank = 'Wraith';
        color = '#4da6ff'; // blue
      } else if (score < 120) {
        newRank = 'Nightblade';
        color = '#b266ff'; // purple
      } else if (score < 200) {
        newRank = 'Void Reaper';
        color = '#ff4444'; // red
      } else {
        newRank = 'Apex Shade';
        color = '#ffd700'; // gold
      }

      player.rank = newRank;
      player.glowColor = color;
      rankText.textContent = newRank;
    }

    function spawnEnemy() {
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      const margin = 40;

      if (edge === 0) { // top
        x = Math.random() * width;
        y = -margin;
      } else if (edge === 1) { // right
        x = width + margin;
        y = Math.random() * height;
      } else if (edge === 2) { // bottom
        x = Math.random() * width;
        y = height + margin;
      } else { // left
        x = -margin;
        y = Math.random() * height;
      }

      const speed = 0.7 + Math.random() * (0.4 + wave * 0.1);
      const enemy = {
        x,
        y,
        radius: 20 + Math.random() * 6,
        speed,
        hp: 3 + wave,
        maxHp: 3 + wave,
        damage: 8 + wave * 1.2,
        attackRange: 26,
        attackCooldown: 900,
        lastAttack: 0,
        eyeGlow: '#'+['33ffcc','ff3366','66aaff','ffcc33'][Math.floor(Math.random()*4)]
      };
      enemies.push(enemy);
    }

    function spawnFogParticle() {
      const p = {
        x: Math.random() * width,
        y: Math.random() * height,
        radius: 20 + Math.random() * 60,
        alpha: 0.02 + Math.random() * 0.05,
        driftX: (Math.random() - 0.5) * 0.1,
        driftY: (Math.random() - 0.5) * 0.1
      };
      particles.push(p);
    }

    for (let i = 0; i < 40; i++) spawnFogParticle();

    function spawnProjectile(target) {
      const angle = Math.atan2(target.y - player.y, target.x - player.x);
      const speed = 6;
      const proj = {
        x: player.x,
        y: player.y,
        radius: 6,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        damage: 4 + wave * 0.8,
        life: 800 // ms
      };
      projectiles.push(proj);
    }

    function update(dt) {
      if (gameOver) return;

      // Fog
      particles.forEach(p => {
        p.x += p.driftX * dt;
        p.y += p.driftY * dt;
        if (p.x < -100) p.x = width + 100;
        if (p.x > width + 100) p.x = -100;
        if (p.y < -100) p.y = height + 100;
        if (p.y > height + 100) p.y = -100;
      });

      // Player dash
      if (player.dashTime > 0) {
        const dashStep = player.dashSpeed * (dt / 16);
        player.x += player.dashDir.x * dashStep;
        player.y += player.dashDir.y * dashStep;
        player.dashTime -= dt;
      }

      // Clamp player to screen
      player.x = Math.max(player.radius, Math.min(width - player.radius, player.x));
      player.y = Math.max(player.radius, Math.min(height - player.radius, player.y));

      // Enemy spawn / waves
      spawnTimer += dt;
      if (spawnTimer > spawnInterval) {
        spawnTimer = 0;
        for (let i = 0; i < 1 + Math.floor(wave * 0.6); i++) {
          spawnEnemy();
        }
        wave++;
        waveText.textContent = wave;
        spawnInterval = Math.max(500, 1200 - wave * 20);
      }

      // Enemies
      const now = performance.now();
      enemies.forEach(enemy => {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);

        if (dist > 1) {
          const nx = dx / dist;
          const ny = dy / dist;
          enemy.x += nx * enemy.speed * (dt / 16);
          enemy.y += ny * enemy.speed * (dt / 16);
        }

        // Attack player
        if (dist < enemy.attackRange + player.radius) {
          if (now - enemy.lastAttack > enemy.attackCooldown) {
            enemy.lastAttack = now;
            player.hp -= enemy.damage;
            hpText.textContent = Math.max(0, Math.floor(player.hp));
            // small hit flash via particles
            for (let i = 0; i < 6; i++) {
              particles.push({
                x: player.x,
                y: player.y,
                radius: 6 + Math.random() * 10,
                alpha: 0.15,
                driftX: (Math.random() - 0.5) * 0.8,
                driftY: (Math.random() - 0.5) * 0.8
              });
            }
            if (player.hp <= 0) {
              gameOver = true;
            }
          }
        }
      });

      // Auto‑attack: find nearest enemy in range
      if (now - player.lastAttack > player.attackCooldown) {
        let nearest = null;
        let nearestDist = Infinity;
        enemies.forEach(enemy => {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const dist = Math.hypot(dx, dy);
          if (dist < player.attackRange && dist < nearestDist) {
            nearestDist = dist;
            nearest = enemy;
          }
        });

        if (nearest) {
          player.lastAttack = now;
          spawnProjectile(nearest);
        }
      }

      // Projectiles
      projectiles.forEach(proj => {
        proj.x += proj.vx * (dt / 16);
        proj.y += proj.vy * (dt / 16);
        proj.life -= dt;
      });

      // Projectile‑enemy collisions
      projectiles.forEach((proj) => {
        enemies.forEach((enemy) => {
          const dx = enemy.x - proj.x;
          const dy = enemy.y - proj.y;
          const dist = Math.hypot(dx, dy);
          if (dist < enemy.radius + proj.radius) {
            enemy.hp -= proj.damage;
            proj.life = 0;
            // hit particles
            for (let i = 0; i < 5; i++) {
              particles.push({
                x: enemy.x,
                y: enemy.y,
                radius: 4 + Math.random() * 8,
                alpha: 0.2,
                driftX: (Math.random() - 0.5) * 1.2,
                driftY: (Math.random() - 0.5) * 1.2
              });
            }
          }
        });
      });

      // Cleanup
      enemies = enemies.filter(e => {
        if (e.hp <= 0) {
          score += 5;
          scoreText.textContent = score;
          updateRank();
          return false;
        }
        return true;
      });

      projectiles = projectiles.filter(p => p.life > 0 &&
        p.x > -50 && p.x < width + 50 &&
        p.y > -50 && p.y < height + 50);
    }

    function draw() {
      // Background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, width, height);

      // Fog
      particles.forEach(p => {
        const gradient = ctx.createRadialGradient(
          p.x, p.y, 0,
          p.x, p.y, p.radius
        );
        gradient.addColorStop(0, `rgba(255,255,255,${p.alpha})`);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      });

      // Enemies
      enemies.forEach(enemy => {
        // body
        ctx.save();
        ctx.translate(enemy.x, enemy.y);
        ctx.fillStyle = 'rgba(0,0,0,0.9)';
        ctx.beginPath();
        ctx.ellipse(0, 0, enemy.radius * 0.7, enemy.radius * 1.4, 0, 0, Math.PI * 2);
        ctx.fill();

        // glow outline
        const glow = ctx.createRadialGradient(0, 0, enemy.radius * 0.4, 0, 0, enemy.radius * 1.4);
        glow.addColorStop(0, 'rgba(0,0,0,0)');
        glow.addColorStop(1, 'rgba(0,0,0,0.8)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.ellipse(0, 0, enemy.radius * 0.9, enemy.radius * 1.6, 0, 0, Math.PI * 2);
        ctx.fill();

        // eyes
        ctx.fillStyle = enemy.eyeGlow;
        ctx.shadowColor = enemy.eyeGlow;
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(-enemy.radius * 0.25, -enemy.radius * 0.2, 3, 0, Math.PI * 2);
        ctx.arc(enemy.radius * 0.25, -enemy.radius * 0.2, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // Projectiles
      projectiles.forEach(proj => {
        const gradient = ctx.createRadialGradient(
          proj.x, proj.y, 0,
          proj.x, proj.y, proj.radius * 2
        );
        gradient.addColorStop(0, player.glowColor);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.radius * 2, 0, Math.PI * 2);
        ctx.fill();
      });

      // Player
      ctx.save();
      ctx.translate(player.x, player.y);

      // glow
      const glow = ctx.createRadialGradient(0, 0, player.radius * 0.4, 0, 0, player.radius * 2.2);
      glow.addColorStop(0, player.glowColor + 'ff'.slice(0,0)); // hack to keep string
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, 0, player.radius * 2.2, 0, Math.PI * 2);
      ctx.fill();

      // silhouette
      ctx.fillStyle = 'rgba(0,0,0,0.95)';
      ctx.beginPath();
      ctx.ellipse(0, 0, player.radius * 0.7, player.radius * 1.4, 0, 0, Math.PI * 2);
      ctx.fill();

      // subtle head
      ctx.beginPath();
      ctx.arc(0, -player.radius * 0.9, player.radius * 0.45, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'center';
        ctx.font = '24px system-ui';
        ctx.fillText('You fell into the void.', width / 2, height / 2 - 10);
        ctx.font = '16px system-ui';
        ctx.fillText('Refresh to restart Rag Doll Arena.', width / 2, height / 2 + 20);
      }
    }

    function loop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    updateRank();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
